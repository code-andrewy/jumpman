<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jumpman64 ‚Äî Fetch & Run Games</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<style>
:root{--bg:#0b0b0b;--muted:rgba(255,255,255,0.65)}
*{box-sizing:border-box}
body{
  background:var(--bg);
  color:#fff;
  font-family:"Segoe UI",Arial,sans-serif;
  margin:0;padding:0;overflow-x:hidden;
  -webkit-font-smoothing:antialiased;
}

/* Header */
header{
  background:rgba(20,20,20,0.45);
  padding:14px 20px;
  display:flex;
  gap:18px;
  align-items:center;
  justify-content:center;
  position:sticky;top:0;z-index:60;
  border-bottom:1px solid rgba(255,255,255,0.04);
  backdrop-filter: blur(8px);
}
.header-left{position:relative}

/* Search */
#search{
  padding:12px 14px;
  width:320px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.08);
  background:rgba(255,255,255,0.03);
  color:#fff;
  outline:none;
}
#search:focus{width:380px;transform:scale(1.01)}

.suggestions{
  position:absolute;left:0;top:46px;
  width:320px;background:rgba(18,18,18,0.95);
  border-radius:12px;padding:6px;display:none;z-index:200;
  box-shadow:0 8px 30px rgba(0,0,0,0.6);
}
.suggestions.show{display:block}
.suggestions div{padding:10px;border-radius:10px;cursor:pointer}
.suggestions div:hover{background:rgba(255,255,255,0.02)}

/* Header widgets */
#streak{font-weight:600}
#weather{display:flex;gap:8px;align-items:center}

/* Sections */
section{display:flex;flex-direction:column;align-items:center;margin:22px 14px;opacity:0;transform:translateY(20px);animation:fadeInUp .7s forwards}
section h2{margin:6px 0 16px;font-size:1.6rem;letter-spacing:0.6px}

/* Lists */
#highlightList,#gameList,#favList,#continueList{display:flex;flex-wrap:wrap;gap:18px;justify-content:center;max-width:1400px}

/* Card */
.game-card{
  width:220px;background:rgba(255,255,255,0.03);padding:16px;border-radius:14px;
  text-align:center;position:relative;cursor:pointer;border:1px solid rgba(255,255,255,0.04);
  transform-origin:center center;box-shadow:0 8px 28px rgba(0,0,0,0.5);
  opacity:0;animation:fadeInCard .6s forwards;
}
.game-card:hover{transform:translateY(-6px) scale(1.04);background:rgba(255,255,255,0.04)}
.thumb-wrapper{height:140px;overflow:hidden;border-radius:10px}
.thumb{width:100%;height:100%;object-fit:cover;display:block}

/* icons */
.bookmark-icon{position:absolute;top:10px;left:10px;background:rgba(0,0,0,0.45);padding:6px 8px;border-radius:10px}
.bookmark-icon i{color:#fff}
.bookmark-icon i.bookmarked{color:#1e90ff}
.remove-icon{position:absolute;top:10px;right:10px;background:rgba(255,0,0,0.18);padding:6px;border-radius:10px}
.remove-icon i{color:#fff}

/* Player overlay */
#player{position:fixed;inset:0;background:#000;display:none;flex-direction:column;z-index:999}
#playerHeader{position:relative;padding:12px}
#backBtn{position:absolute;top:14px;left:14px;background:rgba(32,32,32,0.9);padding:10px;border-radius:12px;cursor:pointer;z-index:1100;border:1px solid rgba(255,255,255,0.04)}
#backBtn i{font-size:18px}
#playerTitle{position:absolute;top:14px;left:50%;transform:translateX(-50%);background:rgba(28,28,28,0.8);padding:8px 16px;border-radius:12px;z-index:1100}
#gameContainer{flex:1;overflow:auto;padding:18px}

/* injected wrapper */
.injected-wrapper{min-height:100%;width:100%}

/* no-results */
.no-results{text-align:center;padding:24px;color:var(--muted)}

/* Animations */
@keyframes fadeInUp{0%{opacity:0;transform:translateY(20px)}100%{opacity:1;transform:none}}
@keyframes fadeInCard{0%{opacity:0;transform:translateY(20px) scale(.95)}50%{transform:translateY(8px) scale(1.01)}100%{opacity:1;transform:none}}
</style>
</head>
<body>

<header>
  <div class="header-left">
    <input id="search" placeholder="Search games..." />
    <div id="suggestions" class="suggestions"></div>
  </div>
  <div id="streak">Streak: üî• 0</div>
  <div id="weather"><span id="weatherEmoji">‚òÅÔ∏è</span>&nbsp;<span id="weatherText">Loading weather...</span></div>
</header>

<!-- PLAYER -->
<div id="player">
  <div id="playerHeader">
    <div id="backBtn" title="Close (Esc)"><i class="fa-solid fa-x"></i></div>
    <h3 id="playerTitle"></h3>
  </div>
  <div id="gameContainer"></div>
</div>

<!-- Highlight -->
<section id="highlightSection" style="display:none;">
  <h2><i class="fa-solid fa-star"></i> Highlights</h2>
  <div id="highlightList"></div>
</section>

<!-- Continue -->
<section id="continue" style="display:none;">
  <h2><i class="fa-solid fa-clock-rotate-left"></i> Continue Playing</h2>
  <div id="continueList"></div>
</section>

<!-- Favorites -->
<section id="favorites" style="display:none;">
  <h2><i class="fa-solid fa-bookmark"></i> Bookmarks</h2>
  <div id="favList"></div>
</section>

<!-- Results -->
<section id="results">
  <h2><i class="fa-solid fa-rocket"></i> Jumpman64</h2>
  <div id="gameList"></div>
</section>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
<script>
/* ===================== FULL BUG-FIXED JS ===================== */
/* Assumes your HTML contains:
   #gameList, #highlightList, #favList, #continueList,
   #continue (section), #favorites (section), #highlightSection,
   #search, #suggestions, #streak,
   #player, #playerTitle, #backBtn, #gameContainer
*/

(() => {
  /* ------------------ Elements ------------------ */
  const gameList = document.getElementById("gameList");
  const highlightList = document.getElementById("highlightList");
  const favList = document.getElementById("favList");
  const continueList = document.getElementById("continueList");
  const continueSection = document.getElementById("continue");
  const favoriteSection = document.getElementById("favorites");
  const highlightSection = document.getElementById("highlightSection");
  const search = document.getElementById("search");
  const suggestions = document.getElementById("suggestions");
  const streakEl = document.getElementById("streak");

  const player = document.getElementById("player");
  const playerTitle = document.getElementById("playerTitle");
  const backBtn = document.getElementById("backBtn");
  const gameContainer = document.getElementById("gameContainer");

  if (!gameContainer) {
    // ensure container exists
    const container = document.createElement("div");
    container.id = "gameContainer";
    container.style.flex = "1";
    container.style.overflow = "hidden";
    player.appendChild(container);
  }

  /* ------------------ State ------------------ */
  let allGames = [];
  let favorites = JSON.parse(localStorage.getItem("favorites") || "[]");
  let lastPlayed = JSON.parse(localStorage.getItem("continue") || "null");
  let isSearching = false;

  // lazy load state
  let currentIndex = 0;
  const cardsPerRow = 5;
  const rowsPerBatch = 3;

  /* ------------------ Storage helpers ------------------ */
  function saveFavorites() {
    localStorage.setItem("favorites", JSON.stringify(favorites));
  }
  function saveContinue(name) {
    localStorage.setItem("continue", JSON.stringify(name));
  }

  /* ------------------ Utility helpers ------------------ */
  function makeAbsoluteIfNeeded(urlStr, base) {
    try {
      if (!urlStr) return urlStr;
      if (/^(data:|https?:|\/\/)/i.test(urlStr)) return urlStr;
      return new URL(urlStr, base).toString();
    } catch (e) {
      return urlStr;
    }
  }

  function addClassOnce(el, cls) {
    if (!el.classList.contains(cls)) el.classList.add(cls);
  }

  function debounce(fn, ms = 200) {
    let t;
    return (...a) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...a), ms);
    };
  }

  /* ------------------ PLAYER: fetch & load via iframe srcdoc ------------------ */
  async function openGame(name, url) {
    try {
      saveContinue(name);
      lastPlayed = name;
      player.style.display = "flex";
      playerTitle.textContent = name;

      // remove any previous iframe quickly (cleanup)
      gameContainer.innerHTML = `<div style="padding:18px;text-align:center;color:#aaa">Loading game...</div>`;

      // fetch raw HTML first (so we can insert <base> and do other small fixes)
      let response;
      try {
        response = await fetch(url, { cache: "no-store" });
      } catch (err) {
        console.warn("Fetch failed, will fallback to iframe.src:", err);
        // fallback: create plain iframe that points to url
        createAndAppendIframe(url, name);
        renderContinue();
        return;
      }

      if (!response || !response.ok) {
        console.warn("Fetch returned non-OK, falling back to direct iframe:", response && response.status);
        createAndAppendIframe(url, name);
        renderContinue();
        return;
      }

      const text = await response.text();

      // parse to detect <base> or to compute base URL
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, "text/html");

      // compute base URL (directory of file)
      let baseUrl = url;
      try {
        const u = new URL(url);
        u.pathname = u.pathname.replace(/\/[^\/]*$/, "/");
        baseUrl = u.toString();
      } catch (e) {
        // leave baseUrl as url
      }

      // ensure there's a <base href="..."> so relative URLs in srcdoc resolve to original directory
      // Build modified HTML string: if there's a head tag insert/replace base, else create head
      let modified = text;
      const hasHead = /<head[\s\S]*?>/i.test(text);
      const baseTag = doc.querySelector("base[href]");
      if (baseTag) {
        // if fetched HTML already has base, leave it
        modified = text;
      } else {
        // inject <base>
        const baseElement = `<base href="${baseUrl}">`;
        if (hasHead) {
          // insert base as first child of head
          modified = text.replace(/<head([^>]*)>/i, match => `${match}\n${baseElement}\n`);
        } else {
          // no head -> create one
          modified = `<!doctype html><html><head>${baseElement}</head>${text}</html>`;
        }
      }

      // create iframe with srcdoc
      createAndAppendIframeFromSrcdoc(modified, name, baseUrl);
      renderContinue();
    } catch (err) {
      console.error("openGame error:", err);
      gameContainer.innerHTML = `<div style="padding:20px;color:#f88">Failed to load game: ${err.message}</div>`;
    }
  }

  // Create iframe and append to gameContainer using srcdoc
  function createAndAppendIframeFromSrcdoc(htmlString, title, baseUrl) {
    // remove any previous iframe
    gameContainer.innerHTML = "";

    const iframe = document.createElement("iframe");
    iframe.style.width = "100%";
    iframe.style.height = "100%";
    iframe.style.border = "none";
    iframe.allow = "fullscreen; autoplay; clipboard-write; encrypted-media; gamepad; display-capture;";
    // allow-same-origin so resource resolution and some features behave; may not be needed but improves compatibility
    // sandbox: if you want stricter isolation, lower permissions (but games often need scripts and same-origin semantics).
    // We provide a fairly permissive sandbox that still executes scripts.
    iframe.setAttribute("sandbox", "allow-scripts allow-forms allow-modals allow-pointer-lock allow-popups allow-same-origin");

    // set srcdoc last (some browsers process attribute order better)
    try {
      iframe.srcdoc = htmlString;
    } catch (e) {
      // Some older browsers might throw ‚Äî fallback to setting src to baseUrl
      console.warn("srcdoc failed, falling back to src:", e);
      iframe.src = baseUrl;
    }

    // attach events (optional: loading indicator / error)
    const loadingIndicator = document.createElement("div");
    loadingIndicator.style.position = "absolute";
    loadingIndicator.style.inset = "0";
    loadingIndicator.style.display = "flex";
    loadingIndicator.style.justifyContent = "center";
    loadingIndicator.style.alignItems = "center";
    loadingIndicator.style.pointerEvents = "none";
    loadingIndicator.style.color = "#999";
    loadingIndicator.innerText = "Loading...";
    gameContainer.style.position = "relative";
    gameContainer.appendChild(loadingIndicator);

    iframe.addEventListener("load", () => {
      try {
        loadingIndicator.remove();
      } catch (e) {}
    });

    iframe.addEventListener("error", () => {
      try {
        loadingIndicator.remove();
      } catch (e) {}
    });

    gameContainer.appendChild(iframe);

    // store reference so we can remove quickly later
    gameContainer._currentIframe = iframe;
  }

  // Fallback: if we can't use srcdoc, set iframe.src = url
  function createAndAppendIframe(url, name) {
    gameContainer.innerHTML = "";
    const iframe = document.createElement("iframe");
    iframe.style.width = "100%";
    iframe.style.height = "100%";
    iframe.style.border = "none";
    iframe.allow = "fullscreen; autoplay; encrypted-media; gamepad; display-capture;";
    // don't use sandbox when navigating to external resource (so game can run fully)
    iframe.src = url;

    // loading indicator
    const loadingIndicator = document.createElement("div");
    loadingIndicator.style.position = "absolute";
    loadingIndicator.style.inset = "0";
    loadingIndicator.style.display = "flex";
    loadingIndicator.style.justifyContent = "center";
    loadingIndicator.style.alignItems = "center";
    loadingIndicator.style.pointerEvents = "none";
    loadingIndicator.style.color = "#999";
    loadingIndicator.innerText = "Loading...";
    gameContainer.style.position = "relative";
    gameContainer.appendChild(loadingIndicator);

    iframe.addEventListener("load", () => {
      try { loadingIndicator.remove(); } catch (e) {}
    });
    iframe.addEventListener("error", () => {
      try { loadingIndicator.remove(); } catch (e) {}
    });

    gameContainer.appendChild(iframe);
    gameContainer._currentIframe = iframe;
  }

  /* ------------------ Back button / cleanup ------------------ */
  function closePlayer() {
    // remove iframe (this stops audio, scripts, etc.)
    try {
      if (gameContainer._currentIframe) {
        // remove src and then element to ensure resource stop
        try { gameContainer._currentIframe.src = "about:blank"; } catch (e) {}
        gameContainer._currentIframe.remove();
        delete gameContainer._currentIframe;
      } else {
        // fallback: clear innerHTML
        gameContainer.innerHTML = "";
      }
    } catch (e) {
      console.warn("Error while removing iframe:", e);
      gameContainer.innerHTML = "";
    }

    // hide player
    player.style.display = "none";
    playerTitle.textContent = "";
    // also remove any leftover audio tags on parent (defensive)
    document.querySelectorAll("audio, video").forEach(v => {
      try { if (v.paused === false) v.pause(); } catch (e) {}
    });
  }

  backBtn.onclick = () => closePlayer();
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && player.style.display === "flex") {
      closePlayer();
    }
  });

  /* ------------------ Fetch games list ------------------ */
  const LIST_URL = "https://raw.githubusercontent.com/code-andrewy/jumpman/refs/heads/main/list.text";

  async function loadGameList() {
    try {
      const res = await fetch(LIST_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("List fetch failed: " + res.status);
      const raw = await res.text();
      const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      for (let i = 0; i < lines.length; i += 3) {
        const url = (lines[i] || "").replace(/^Website url:/i, "").trim();
        const name = (lines[i + 1] || "").replace(/^Game name:/i, "").trim();
        const img = (lines[i + 2] || "").replace(/^Image url:/i, "").trim();
        if (url && name) allGames.push({ url, name, img });
      }
      renderHighlightOfDay();
      renderFavorites();
      renderContinue();
      loadNextBatch();
    } catch (err) {
      console.error("Failed to load list", err);
      gameList.innerHTML = `<div class="no-results" style="padding:20px;color:#f88">Failed to load games list.</div>`;
    }
  }

  /* ------------------ RNG for highlight ------------------ */
  function seededRandom(seed) {
    return (Math.sin(seed) * 10000) % 1;
  }

  /* ------------------ Card creation (animations included) ------------------ */
  function createCard(g, delay = 0, isRemovable = false) {
    const isFav = favorites.includes(g.name);
    const div = document.createElement("div");
    div.className = "game-card";
    div.style.animationDelay = `${(delay * 0.04).toFixed(2)}s`;
    div.innerHTML = `
      <div class="thumb-wrapper"><img src="${g.img || ""}" alt="${escapeHtml(g.name)}" class="thumb" /></div>
      <strong style="display:block;margin-top:10px">${escapeHtml(g.name)}</strong>
      <div class="bookmark-icon" title="Bookmark"><i class="fa-solid fa-bookmark ${isFav ? "bookmarked" : ""}"></i></div>
    `;

    const thumb = div.querySelector(".thumb-wrapper");
    thumb.addEventListener("click", (e) => {
      e.preventDefault();
      openGame(g.name, g.url);
    });

    const bookmark = div.querySelector(".bookmark-icon");
    bookmark.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleFavorite(g.name, bookmark);
    });

    if (isRemovable) {
      const rm = document.createElement("div");
      rm.className = "remove-icon";
      rm.innerHTML = '<i class="fa-solid fa-trash"></i>';
      rm.addEventListener("click", (e) => {
        e.stopPropagation();
        removeFavorite(g.name);
      });
      div.appendChild(rm);
    }

    return div;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (m) => {
      return ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[m];
    });
  }

  /* ------------------ Highlight of day ------------------ */
  function renderHighlightOfDay() {
    if (!allGames.length) return;
    highlightSection.style.display = "block";
    highlightList.innerHTML = "";
    const today = new Date();
    const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
    const shuffled = [...allGames].sort(
      (a, b) => seededRandom(seed + a.name.charCodeAt(0)) - seededRandom(seed + b.name.charCodeAt(0))
    );
    shuffled.slice(0, 5).forEach((g, i) => highlightList.appendChild(createCard(g, i)));
  }

  /* ------------------ Lazy load (in batches) ------------------ */
  function loadNextBatch() {
    const batchSize = cardsPerRow * rowsPerBatch;
    const end = Math.min(currentIndex + batchSize, allGames.length);
    for (let i = currentIndex; i < end; i++) {
      gameList.appendChild(createCard(allGames[i], i - currentIndex));
    }
    currentIndex = end;
  }

  window.addEventListener("scroll", () => {
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 300) {
      if (!isSearching && currentIndex < allGames.length) loadNextBatch();
    }
  });

  /* ------------------ Favorites ------------------ */
  function toggleFavorite(name, iconEl) {
    const iEl = iconEl.querySelector("i");
    if (!favorites.includes(name)) {
      favorites.push(name);
      iEl.classList.add("bookmarked");
    } else {
      favorites = favorites.filter((f) => f !== name);
      iEl.classList.remove("bookmarked");
    }
    saveFavorites();
    renderFavorites();
  }

  function renderFavorites() {
    if (!favorites.length) {
      favoriteSection.style.display = "none";
      return;
    }
    favoriteSection.style.display = "block";
    favList.innerHTML = "";
    favorites.forEach((name) => {
      const game = allGames.find((g) => g.name === name);
      if (game) favList.appendChild(createCard(game, 0, true));
    });
  }

  function removeFavorite(name) {
    favorites = favorites.filter((f) => f !== name);
    saveFavorites();
    renderFavorites();
  }

  /* ------------------ Continue ------------------ */
  function removeContinue() {
    lastPlayed = null;
    saveContinue(null);
    renderContinue();
  }

  function renderContinue() {
    if (!lastPlayed) {
      continueSection.style.display = "none";
      return;
    }
    const game = allGames.find((g) => g.name === lastPlayed);
    if (!game) return;
    continueSection.style.display = "block";
    continueList.innerHTML = "";
    continueList.appendChild(createCard(game, 0, true));
  }

  /* ------------------ Search with suggestions (debounced) ------------------ */
  function showNoResults() {
    gameList.innerHTML = `<div class="no-results"><h2>‚ö†Ô∏è No results found</h2></div>`;
  }

  function renderFilteredResults(filtered) {
    isSearching = true;
    gameList.innerHTML = "";
    if (!filtered.length) return showNoResults();
    filtered.forEach((g, i) => gameList.appendChild(createCard(g, i)));
  }

  const handleSearch = debounce(() => {
    const q = (search.value || "").toLowerCase().trim();
    suggestions.innerHTML = "";

    if (!q) {
      isSearching = false;
      suggestions.classList.remove("show");
      gameList.innerHTML = "";
      currentIndex = 0;
      loadNextBatch();
      return;
    }

    const filtered = allGames.filter((g) => g.name.toLowerCase().includes(q));
    filtered.slice(0, 6).forEach((g) => {
      const div = document.createElement("div");
      div.textContent = g.name;
      div.addEventListener("click", () => {
        search.value = g.name;
        suggestions.classList.remove("show");
        renderFilteredResults([g]);
      });
      suggestions.appendChild(div);
    });

    suggestions.classList.add("show");
    renderFilteredResults(filtered);
  }, 180);

  search.addEventListener("input", handleSearch);
  document.addEventListener("click", (e) => {
    if (!search.contains(e.target) && !suggestions.contains(e.target)) {
      suggestions.classList.remove("show");
    }
  });

  /* ------------------ Streak ------------------ */
  (function manageStreak() {
    const todayStr = new Date().toISOString().split("T")[0];
    let streakData = JSON.parse(localStorage.getItem("streakData") || '{"count":0,"lastLogin":""}');
    if (streakData.lastLogin !== todayStr) {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      streakData.count = streakData.lastLogin === yesterday.toISOString().split("T")[0] ? streakData.count + 1 : 1;
      streakData.lastLogin = todayStr;
      localStorage.setItem("streakData", JSON.stringify(streakData));
    }
    streakEl.textContent = `Streak:üî• ${streakData.count}`;
  })();

  /* ------------------ Weather (api.weather.gov) ------------------ */
  $(document).ready(function () {
    const loc = { lat: 43.4426, lon: -71.2776 };
    function getWeather(lat, lon) {
      $.ajax({
        url: `https://api.weather.gov/points/${lat},${lon}`,
        success: (data) => {
          $.ajax({
            url: data.properties.forecast,
            success: (fore) => {
              const f = fore.properties.periods[0];
              $("#weatherText").text(`${f.temperature}¬∞${f.temperatureUnit} ‚Äî ${f.shortForecast}`);
              let emoji = "‚òÅÔ∏è";
              if (/sunny/i.test(f.shortForecast)) emoji = "‚òÄÔ∏è";
              else if (/rain/i.test(f.shortForecast)) emoji = "üåßÔ∏è";
              else if (/snow/i.test(f.shortForecast)) emoji = "‚ùÑÔ∏è";
              else if (/storm|thunder/i.test(f.shortForecast)) emoji = "‚õàÔ∏è";
              else if (/clear/i.test(f.shortForecast)) emoji = "üåû";
              $("#weatherEmoji").text(emoji);
            },
            error: () => {
              $("#weatherText").text("Weather unavailable");
            },
          });
        },
        error: () => {
          $("#weatherText").text("Weather unavailable");
        },
      });
    }

    try {
      getWeather(loc.lat, loc.lon);
      setInterval(() => getWeather(loc.lat, loc.lon), 300000);
    } catch (e) {
      console.warn("Weather failed:", e);
    }
  });

  /* ------------------ Bootstrap: load list ------------------ */
  loadGameList();

  /* ------------------ Utility: HTML escaping done earlier -------------- */
})();
</script>
</body>
</html>