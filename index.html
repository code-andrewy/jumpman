<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jumpman64 ‚Äî Fetch & Run Games</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<style>
:root{--bg:#0b0b0b;--muted:rgba(255,255,255,0.65)}
*{box-sizing:border-box}
body{
  background:var(--bg);
  color:#fff;
  font-family:"Segoe UI",Arial,sans-serif;
  margin:0;padding:0;overflow-x:hidden;
  -webkit-font-smoothing:antialiased;
}

/* Header */
header{
  background:rgba(20,20,20,0.45);
  padding:14px 20px;
  display:flex;
  gap:18px;
  align-items:center;
  justify-content:center;
  position:sticky;top:0;z-index:60;
  border-bottom:1px solid rgba(255,255,255,0.04);
  backdrop-filter: blur(8px);
}
.header-left{position:relative}

/* Search */
#search{
  padding:12px 14px;
  width:320px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.08);
  background:rgba(255,255,255,0.03);
  color:#fff;
  outline:none;
}
#search:focus{width:380px;transform:scale(1.01)}

.suggestions{
  position:absolute;left:0;top:46px;
  width:320px;background:rgba(18,18,18,0.95);
  border-radius:12px;padding:6px;display:none;z-index:200;
  box-shadow:0 8px 30px rgba(0,0,0,0.6);
}
.suggestions.show{display:block}
.suggestions div{padding:10px;border-radius:10px;cursor:pointer}
.suggestions div:hover{background:rgba(255,255,255,0.02)}

/* Header widgets */
#streak{font-weight:600}
#weather{display:flex;gap:8px;align-items:center}

/* Sections */
section{display:flex;flex-direction:column;align-items:center;margin:22px 14px;opacity:0;transform:translateY(20px);animation:fadeInUp .7s forwards}
section h2{margin:6px 0 16px;font-size:1.6rem;letter-spacing:0.6px}

/* Lists */
#highlightList,#gameList,#favList,#continueList{display:flex;flex-wrap:wrap;gap:18px;justify-content:center;max-width:1400px}

/* Card */
.game-card{
  width:220px;background:rgba(255,255,255,0.03);padding:16px;border-radius:14px;
  text-align:center;position:relative;cursor:pointer;border:1px solid rgba(255,255,255,0.04);
  transform-origin:center center;box-shadow:0 8px 28px rgba(0,0,0,0.5);
  opacity:0;animation:fadeInCard .6s forwards;
}
.game-card:hover{transform:translateY(-6px) scale(1.04);background:rgba(255,255,255,0.04)}
.thumb-wrapper{height:140px;overflow:hidden;border-radius:10px}
.thumb{width:100%;height:100%;object-fit:cover;display:block}

/* icons */
.bookmark-icon{position:absolute;top:10px;left:10px;background:rgba(0,0,0,0.45);padding:6px 8px;border-radius:10px}
.bookmark-icon i{color:#fff}
.bookmark-icon i.bookmarked{color:#1e90ff}
.remove-icon{position:absolute;top:10px;right:10px;background:rgba(255,0,0,0.18);padding:6px;border-radius:10px}
.remove-icon i{color:#fff}

/* Player overlay */
#player{position:fixed;inset:0;background:#000;display:none;flex-direction:column;z-index:999}
#playerHeader{position:relative;padding:12px}
#backBtn{position:absolute;top:14px;left:14px;background:rgba(32,32,32,0.9);padding:10px;border-radius:12px;cursor:pointer;z-index:1100;border:1px solid rgba(255,255,255,0.04)}
#backBtn i{font-size:18px}
#playerTitle{position:absolute;top:14px;left:50%;transform:translateX(-50%);background:rgba(28,28,28,0.8);padding:8px 16px;border-radius:12px;z-index:1100}
#gameContainer{flex:1;overflow:auto;padding:18px}

/* injected wrapper */
.injected-wrapper{min-height:100%;width:100%}

/* no-results */
.no-results{text-align:center;padding:24px;color:var(--muted)}

/* Animations */
@keyframes fadeInUp{0%{opacity:0;transform:translateY(20px)}100%{opacity:1;transform:none}}
@keyframes fadeInCard{0%{opacity:0;transform:translateY(20px) scale(.95)}50%{transform:translateY(8px) scale(1.01)}100%{opacity:1;transform:none}}
</style>
</head>
<body>

<header>
  <div class="header-left">
    <input id="search" placeholder="Search games..." />
    <div id="suggestions" class="suggestions"></div>
  </div>
  <div id="streak">Streak: üî• 0</div>
  <div id="weather"><span id="weatherEmoji">‚òÅÔ∏è</span>&nbsp;<span id="weatherText">Loading weather...</span></div>
</header>

<!-- PLAYER -->
<div id="player">
  <div id="playerHeader">
    <div id="backBtn" title="Close (Esc)"><i class="fa-solid fa-x"></i></div>
    <h3 id="playerTitle"></h3>
  </div>
  <div id="gameContainer"></div>
</div>

<!-- Highlight -->
<section id="highlightSection" style="display:none;">
  <h2><i class="fa-solid fa-star"></i> Highlights</h2>
  <div id="highlightList"></div>
</section>

<!-- Continue -->
<section id="continue" style="display:none;">
  <h2><i class="fa-solid fa-clock-rotate-left"></i> Continue Playing</h2>
  <div id="continueList"></div>
</section>

<!-- Favorites -->
<section id="favorites" style="display:none;">
  <h2><i class="fa-solid fa-bookmark"></i> Bookmarks</h2>
  <div id="favList"></div>
</section>

<!-- Results -->
<section id="results">
  <h2><i class="fa-solid fa-rocket"></i> Jumpman64</h2>
  <div id="gameList"></div>
</section>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
<script>
/* ====== Elements ====== */
const gameList = document.getElementById("gameList");
const highlightList = document.getElementById("highlightList");
const favList = document.getElementById("favList");
const continueList = document.getElementById("continueList");
const continueSection = document.getElementById("continue");
const favoriteSection = document.getElementById("favorites");
const highlightSection = document.getElementById("highlightSection");
const search = document.getElementById("search");
const suggestions = document.getElementById("suggestions");
const streakEl = document.getElementById("streak");

const player = document.getElementById("player");
const playerTitle = document.getElementById("playerTitle");
const backBtn = document.getElementById("backBtn");
const gameContainer = document.getElementById("gameContainer");

/* ====== State ====== */
let allGames = [];
let favorites = JSON.parse(localStorage.getItem("favorites") || "[]");
let lastPlayed = JSON.parse(localStorage.getItem("continue") || "null");
let isSearching = false;

/* nodes injected to document (so we can remove them on cleanup) */
let injectedNodes = [];

/* ====== Storage helpers ====== */
function saveFavorites(){ localStorage.setItem("favorites", JSON.stringify(favorites)); }
function saveContinue(name){ localStorage.setItem("continue", JSON.stringify(name)); }

/* ====== Utility: turn relative -> absolute based on base ====== */
function makeAbsoluteIfNeeded(urlStr, base) {
  try {
    if (!urlStr) return urlStr;
    // leave alone if absolute or data: or // protocol relative
    if (/^(data:|https?:|\/\/)/i.test(urlStr)) return urlStr;
    return new URL(urlStr, base).toString();
  } catch(e) { return urlStr; }
}

/* ====== Cleanup injected content ====== */
function cleanupInjected(){
  // remove wrapper
  const wrapper = gameContainer.querySelector('.injected-wrapper');
  if (wrapper) wrapper.remove();

  // remove tags we appended to head/body
  injectedNodes.forEach(n => { try{ n.remove(); }catch(e){} });
  injectedNodes = [];

  // restore document.write
  if (document._originalWrite) {
    try { document.write = document._originalWrite; } catch(e){}
    delete document._originalWrite;
  }

  // clear title
  playerTitle.textContent = '';
}

/* ====== Open game: fetch + inject ====== */
async function openGame(name, url) {
  saveContinue(name);
  lastPlayed = name;
  player.style.display = "flex";
  playerTitle.textContent = name;

  cleanupInjected();
  gameContainer.innerHTML = `<div style="padding:18px;color:#aaa;text-align:center">Loading game...</div>`;

  let text;
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('HTTP '+res.status);
    text = await res.text();
  } catch (err) {
    gameContainer.innerHTML = `<div style="padding:18px;color:#f88">Failed to load: ${err.message}</div>`;
    console.error(err);
    return;
  }

  const parser = new DOMParser();
  const doc = parser.parseFromString(text, 'text/html');

  // compute base URL (directory of file)
  const baseTag = doc.querySelector('base[href]');
  let baseUrl;
  if (baseTag) baseUrl = baseTag.getAttribute('href');
  else {
    try {
      const u = new URL(url);
      u.pathname = u.pathname.replace(/\/[^\/]*$/, '/');
      baseUrl = u.toString();
    } catch(e){ baseUrl = url; }
  }

  // create wrapper and copy body content
  const wrapper = document.createElement('div');
  wrapper.className = 'injected-wrapper';
  wrapper.innerHTML = doc.body ? doc.body.innerHTML : text;
  gameContainer.innerHTML = '';
  gameContainer.appendChild(wrapper);

  // fix common attributes to absolute
  const ATTRS = ['src','href','action','data-src','poster','srcset'];
  wrapper.querySelectorAll('*').forEach(el => {
    ATTRS.forEach(attr => {
      if (el.hasAttribute && el.hasAttribute(attr)) {
        const val = el.getAttribute(attr);
        if (val) {
          const abs = makeAbsoluteIfNeeded(val, baseUrl);
          if (abs && abs !== val) el.setAttribute(attr, abs);
        }
      }
    });
    // inline style url(...) fix
    if (el.style && el.style.cssText && /url\(/i.test(el.style.cssText)) {
      el.style.cssText = el.style.cssText.replace(/url\((["']?)([^"')]+)\1\)/g, (m,q,p)=>{
        const abs = makeAbsoluteIfNeeded(p, baseUrl);
        return `url("${abs}")`;
      });
    }
  });

  // inject stylesheets from fetched doc into our head
  const linkTags = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'));
  for (const link of linkTags) {
    const href = link.getAttribute('href');
    if (!href) continue;
    const abs = makeAbsoluteIfNeeded(href, baseUrl);
    const newLink = document.createElement('link');
    newLink.rel = 'stylesheet';
    newLink.href = abs;
    document.head.appendChild(newLink);
    injectedNodes.push(newLink);
  }

  // inject style tags
  const styleTags = Array.from(doc.querySelectorAll('style'));
  for (const s of styleTags) {
    const newStyle = document.createElement('style');
    newStyle.textContent = s.textContent;
    document.head.appendChild(newStyle);
    injectedNodes.push(newStyle);
  }

  // override document.write to safely append into wrapper
  if (!document._originalWrite) {
    document._originalWrite = document.write;
    document.write = function(html){
      try { wrapper.insertAdjacentHTML('beforeend', html); }
      catch(e){ console.warn('document.write failed', e); }
    };
  }

  // execute scripts sequentially
  const scripts = Array.from(doc.querySelectorAll('script'));
  for (const s of scripts) {
    const src = s.getAttribute && s.getAttribute('src');
    if (src) {
      const abs = makeAbsoluteIfNeeded(src, baseUrl);
      const newScript = document.createElement('script');
      newScript.src = abs;
      newScript.async = false;
      // append to body so it executes in main context
      await new Promise(resolve => {
        newScript.onload = () => resolve();
        newScript.onerror = () => {
          console.warn('Script failed to load:', abs);
          resolve();
        };
        document.body.appendChild(newScript);
        injectedNodes.push(newScript);
      });
    } else {
      // inline script: run it by creating a script element
      try {
        const newScript = document.createElement('script');
        newScript.textContent = s.textContent;
        document.body.appendChild(newScript);
        injectedNodes.push(newScript);
      } catch(e){ console.warn('Inline script exec failed', e); }
    }
  }

  // update title if provided
  if (doc.title) playerTitle.textContent = doc.title || name;

  // run onload-like inline handlers (best-effort)
  wrapper.querySelectorAll('[onload]').forEach(el => {
    try { new Function(el.getAttribute('onload')).call(el); } catch(e){}
  });

  // ensure continue UI updates
  try { renderContinue(); } catch(e){}
}

/* ====== Back button: cleanup & hide ====== */
backBtn.onclick = () => {
  cleanupInjected();
  player.style.display = 'none';
};

/* also close on Escape */
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && player.style.display === 'flex') {
    cleanupInjected();
    player.style.display = 'none';
  }
});

/* ====== Fetch games list (triples: Website url / Game name / Image url) ====== */
fetch("https://raw.githubusercontent.com/code-andrewy/jumpman/refs/heads/main/list.text")
  .then(r => r.text())
  .then(raw => {
    const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    for (let i = 0; i < lines.length; i += 3) {
      const url = (lines[i]||'').replace(/^Website url:/i,'').trim();
      const name = (lines[i+1]||'').replace(/^Game name:/i,'').trim();
      const img = (lines[i+2]||'').replace(/^Image url:/i,'').trim();
      if (url && name) allGames.push({ url, name, img });
    }
    renderHighlightOfDay();
    renderFavorites();
    renderContinue();
    loadNextBatch();
  })
  .catch(err => {
    console.error('Failed to load list', err);
    gameList.innerHTML = '<div class="no-results">Failed to load games list.</div>';
  });

/* ====== RNG for highlight ====== */
function seededRandom(seed){ return (Math.sin(seed)*10000) % 1; }

/* ====== Create card (with animation delay) ====== */
function createCard(g, delay = 0, isRemovable=false) {
  const isFav = favorites.includes(g.name);
  const div = document.createElement('div');
  div.className = 'game-card';
  div.style.animationDelay = `${(delay*0.04).toFixed(2)}s`;
  div.innerHTML = `
    <div class="thumb-wrapper"><img class="thumb" src="${g.img||''}" alt="${g.name}"></div>
    <strong style="display:block;margin-top:10px">${g.name}</strong>
    <div class="bookmark-icon" title="Bookmark"><i class="fa-solid fa-bookmark ${isFav?'bookmarked':''}"></i></div>
  `;
  div.querySelector('.thumb-wrapper').onclick = () => openGame(g.name, g.url);
  div.querySelector('.bookmark-icon').onclick = (e) => {
    e.stopPropagation();
    toggleFavorite(g.name, div.querySelector('.bookmark-icon'));
  };
  if (isRemovable) {
    const rm = document.createElement('div');
    rm.className = 'remove-icon';
    rm.innerHTML = '<i class="fa-solid fa-trash"></i>';
    rm.onclick = (e) => { e.stopPropagation(); removeFavorite(g.name); };
    div.appendChild(rm);
  }
  return div;
}

/* ====== Highlight of day ====== */
function renderHighlightOfDay(){
  if (!allGames.length) return;
  highlightSection.style.display = 'block';
  highlightList.innerHTML = '';
  const today = new Date();
  const seed = today.getFullYear()*10000 + (today.getMonth()+1)*100 + today.getDate();
  const shuffled = [...allGames].sort((a,b)=> seededRandom(seed + a.name.charCodeAt(0)) - seededRandom(seed + b.name.charCodeAt(0)));
  shuffled.slice(0,5).forEach((g,i)=> highlightList.appendChild(createCard(g,i)));
}

/* ====== Lazy load list ====== */
let currentIndex = 0;
const cardsPerRow = 5;
const rowsPerBatch = 3;
function loadNextBatch(){
  const batchSize = cardsPerRow * rowsPerBatch;
  const end = Math.min(currentIndex + batchSize, allGames.length);
  for (let i = currentIndex; i < end; i++) {
    gameList.appendChild(createCard(allGames[i], i - currentIndex));
  }
  currentIndex = end;
}
window.addEventListener('scroll', ()=> {
  if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 300) {
    if (!isSearching && currentIndex < allGames.length) loadNextBatch();
  }
});

/* ====== Favorites ====== */
function toggleFavorite(name, iconEl){
  const iEl = iconEl.querySelector('i');
  if (!favorites.includes(name)) { favorites.push(name); iEl.classList.add('bookmarked'); }
  else { favorites = favorites.filter(f=>f!==name); iEl.classList.remove('bookmarked'); }
  saveFavorites(); renderFavorites();
}
function renderFavorites(){
  if (!favorites.length) { favoriteSection.style.display='none'; return; }
  favoriteSection.style.display='block'; favList.innerHTML='';
  favorites.forEach(name=>{
    const game = allGames.find(g=>g.name===name);
    if (game) favList.appendChild(createCard(game,0,true));
  });
}
function removeFavorite(name){ favorites = favorites.filter(f=>f!==name); saveFavorites(); renderFavorites(); }

/* ====== Continue ====== */
function removeContinue(){ lastPlayed = null; saveContinue(null); renderContinue(); }
function renderContinue(){
  if (!lastPlayed) { continueSection.style.display='none'; return; }
  const game = allGames.find(g=>g.name===lastPlayed);
  if (!game) return;
  continueSection.style.display='block'; continueList.innerHTML=''; continueList.appendChild(createCard(game,0,true));
}

/* ====== Search & suggestions ====== */
function showNoResults(){ gameList.innerHTML = '<div class="no-results"><h2>‚ö†Ô∏è No results found</h2></div>'; }
function renderFilteredResults(filtered){ isSearching = true; gameList.innerHTML=''; if (!filtered.length){ showNoResults(); return; } filtered.forEach((g,i)=> gameList.appendChild(createCard(g,i))); }
search.addEventListener('input', ()=> {
  const q = search.value.toLowerCase().trim(); suggestions.innerHTML='';
  if (!q) { isSearching=false; suggestions.classList.remove('show'); gameList.innerHTML=''; currentIndex=0; loadNextBatch(); return; }
  const filtered = allGames.filter(g => g.name.toLowerCase().includes(q));
  filtered.slice(0,6).forEach(g=> {
    const d = document.createElement('div');
    d.textContent = g.name;
    d.onclick = ()=> { search.value = g.name; suggestions.classList.remove('show'); renderFilteredResults([g]); };
    suggestions.appendChild(d);
  });
  suggestions.classList.add('show'); renderFilteredResults(filtered);
});
document.addEventListener('click', e => {
  if (!search.contains(e.target) && !suggestions.contains(e.target)) suggestions.classList.remove('show');
});

/* ====== Streak ====== */
const todayStr = new Date().toISOString().split('T')[0];
let streakData = JSON.parse(localStorage.getItem('streakData') || '{"count":0,"lastLogin":""}');
if (streakData.lastLogin !== todayStr) {
  const yesterday = new Date(); yesterday.setDate(yesterday.getDate()-1);
  streakData.count = (streakData.lastLogin === yesterday.toISOString().split('T')[0]) ? streakData.count + 1 : 1;
  streakData.lastLogin = todayStr;
  localStorage.setItem('streakData', JSON.stringify(streakData));
}
streakEl.textContent = `Streak:üî• ${streakData.count}`;

/* ====== Weather ====== */
$(document).ready(function(){
  const loc = { lat: 43.4426, lon: -71.2776 };
  function getWeather(lat, lon) {
    $.ajax({ url:`https://api.weather.gov/points/${lat},${lon}`, success: data => {
      $.ajax({ url: data.properties.forecast, success: fore => {
        const f = fore.properties.periods[0];
        $("#weatherText").text(`${f.temperature}¬∞${f.temperatureUnit} ‚Äî ${f.shortForecast}`);
        let emoji = "‚òÅÔ∏è";
        if (/sunny/i.test(f.shortForecast)) emoji="‚òÄÔ∏è";
        else if (/rain/i.test(f.shortForecast)) emoji="üåßÔ∏è";
        else if (/snow/i.test(f.shortForecast)) emoji="‚ùÑÔ∏è";
        else if (/storm|thunder/i.test(f.shortForecast)) emoji="‚õàÔ∏è";
        else if (/clear/i.test(f.shortForecast)) emoji="üåû";
        $("#weatherEmoji").text(emoji);
      }});
    }});
  }
  getWeather(loc.lat, loc.lon);
  setInterval(()=>getWeather(loc.lat, loc.lon), 300000);
});
</script>
</body>
</html>